-- 실행 계획인 들어있는 테이블 조회
DESC PLAN_TABLE;

-- 실행계획 확인(F10)
SELECT *
 FROM EMP;
 
SELECT *
 FROM BUYTBL;
 
-- 규칙기반 옵티마이저
SELECT /*+ RULE */ ROWID, ENAME, SAL
 FROM EMP
WHERE ROWID = 'AAAST7AAHAAAAEWAAA';


ALTER TABLE USERTBL ADD PRIMARY KEY(USERID);
SELECT *
 FROM USERTBL;
COMMIT;

-- USERTBL의 모든 제약조건을 조회하는 구문
SELECT * FROM ALL_CONSTRAINTS
WHERE  TABLE_NAME = 'USERTBL';

SELECT * FROM ALL_CONSTRAINTS
WHERE  TABLE_NAME = 'EMP';

-- PK지우기
ALTER TABLE USERTBL DROP PRIMARY KEY;
-- PK추가
ALTER TABLE USERTBL ADD PRIMARY KEY(USERID);
-- PK로 인한 자동정렬 및 삭제시 삽입된 정렬순으로 바뀜
SELECT ROWID, USERID FROM USERTBL;


-- 인덱스 유일 스캔 예제
SELECT * FROM EMP
WHERE EMPNO = 1000;

-- 인덱스 범위 스캔 예제
-- 특정범위의 데이터를 스캔할 때 사용되는 방법
SELECT * FROM EMP
WHERE EMPNO >= 1000;

SELECT * FROM EMP
WHERE EMPNO BETWEEN 1000 AND 1005;
-- 아래 코드는 FULL TABLE SCAN을 하고 있다. 그 이유는 범위스캔보다 FULL TABLE SCAN이 COST가 적게 소요된다고
-- 옵티마이저가 선택을 한 것이다.
SELECT * FROM EMP
WHERE EMPNO LIKE '10%';

-- 인덱스 FULL TABLE SCAN
-- FULL TABLE SCAN : 인덱스에서 검색되는 인덱스 키가 많은 경우에 LEAF BLOCK(NODE)의 처음부터 끝까지 전체를 읽어들이는 방법
SELECT ENAME, SAL
 FROM EMP
WHERE ENAME LIKE '%'
   AND SAL > 0;


-- 실행계획
-- 실행계획은 오라클 엔진의 버전의 옵티마이저에 따라서 실행계획이 정해지고 다 똑같은 방법으로 스캔을 하지는 않는다라는 것을 알 수가 
-- 있다.
SELECT * FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10;
   
   
-- NESTED LOOP 조인(의도적 힌트를 주어서 NESETED LOOP를 사용토록 한다)
-- ORDERED힌트는 FROM절에 나오는 테이블의 순서대로 FULL SCAN을 하도록 하고 혼자서는 사용되지 않고 여러가지 힌트와 함께
-- 사용되어진다.
-- 힌트를 주어 규칙 기반이 된다.
SELECT /*+ ORDERED USE_NL(D) */ *
 FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- 비용 기반에서는 HASH JOIN이 되어 결과를 인출한다.(기본적으로 비용 기반이 된다.)
SELECT *
 FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- SORT MERGE
-- ORDERED USE_MERGE 힌트를 사용하여 규칙 기반이 되었다.
SELECT /*+ ORDERED USE_MERGE(D) */ *
 FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10;

-- 비용 기반   
SELECT *
 FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10;
   
-- 해쉬 조인
-- ORDERED USE_HASH라는 힌트를 사용해서 의도적으로 HASH JOIN만들었다.
SELECT /*+ ORDERED USE_HASH(D) */ *
 FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10;
   
-- 비용 기반
SELECT *
 FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
   AND E.DEPTNO = 10;
   
-- 확인문제 6번
-- 테이블 파티션 나누기
DROP TABLE TEST;
CREATE TABLE TEST(A NUMBER, B CHAR(3), C VARCHAR(10) )
 PARTITION BY RANGE(A) (
    PARTITION P1 VALUES LESS THAN(1000),
    PARTITION P2 VALUES LESS THAN(2000),
    PARTITION P3 VALUES LESS THAN(MAXVALUE) );
CREATE INDEX TEST_IDX ON TEST(B) LOCAL;

INSERT INTO TEST PARTITION(P1) VALUES(111, 'AAA', 'BBB');
INSERT INTO TEST PARTITION(P2) VALUES(1011, 'BBB', 'CCC');

-- 파티션 테이블 키 컬럼 조회
SELECT * FROM ALL_PART_KEY_COLUMNS
WHERE NAME = 'TEST';

-- 파티션명 조회
SELECT * FROM ALL_TAB_PARTITIONS
WHERE TABLE_NAME = 'TEST';
COMMIT;


-- 단원 확인 문제 3번
CREATE TABLE STUDENT(
    ID CHAR(10) PRIMARY KEY,
    NAME VARCHAR(20) NOT NULL,
    AGE NUMBER(3) DEFAULT 1    
);
-- 단원 확인 문제 5번
--사원(사번, 이름, 나이)
--가족(이름, 나이, 부양사번)
--가족 테이블의 부양사번은 사원 테이블의 사번을 참조하는 외래키(Foreign Key)이다.
CREATE TABLE 사원(
    EMPNO NUMBER(10) PRIMARY KEY,
    ENAME VARCHAR(10) NOT NULL,
    AGE NUMBER(3) NOT NULL
);
CREATE TABLE 가족(
    FAMILY_NAME VARCHAR(10) NOT NULL,
    AGE NUMBER(3) NOT NULL,
    FAMILY_NUMBER NUMBER(10),
    CONSTRAINT FALMILY_FK FOREIGN KEY(FAMILY_NUMBER) REFERENCES 사원(EMPNO)
);
-- 단원 확인 문제 14번
SELECT NVL(MGR, 9999) FROM EMP;

-- 단원 확인 문제 18번
SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YYYY') FROM DUAL;


-- 단원 확인 문제 20번
SELECT 1 FROM DUAL
UNION
SELECT 2 FROM DUAL
UNION
SELECT 1 FROM DUAL;

-- 단원 확인 문제 23번
SELECT * FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;
-- ANSI/ISO표준
SELECT * FROM EMP 
INNER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;

-- 단원 확인 문제 25번
SELECT * FROM EMP
RIGHT OUTER JOIN DEPT
ON EMP.DEPTNO = DEPT.DEPTNO;

-- 단원 확인 문제 30번
SELECT * FROM EMP
WHERE EMPNO LIKE '100%';
DESC EMP;